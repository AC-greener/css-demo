<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>prototype</title>
</head>
<body>
  <div>
    
  </div>

  <script>
    //创建对象的三种方法
    var o = {name: 'o'}

    var M = function () {
      this.name = 'o1'
    }
    o1 = new M()

    // 通过原型链来连接的
    var p = {name: 'o2'}
    var o2 = Object.create(p)


    //继承的方法
    // function Parent1() {
    //   this.name = 'laowang'
    // }
    // class Parent {
    //   constructor() {
    //     this.name = 'zhansgan'
    //   }
    // }
    
    // console.log(new Parent1(), new Parent())

    //实现继承的方法
    //第一种方法，构造函数   
    function Parent1() {
      this.name = 'laowang'
    }
    Parent1.prototype.say = function() {
      console.log('hello')
    }
    function Child1() {
      Parent1.call(this)   //改变this指向，原型链上的东西并没有被继承
      this.type = 'child1'
    }
    var instance1 = new Child1()
    console.log(instance1)


    //第二种方法 原型链, 缺点：原型对象呗共用
    function Parent2() {
      this.name = 'parent2'
    }
    function Child2() {
      this.name = 'child2'
    }
    Child2.prototype = new Parent2()
    var instance2 = new Child2()
    console.log(instance2)

    //组合继承   父类构造函数执行两次  Child3的构造函数也被修改了，被改成父类的constructor
    function Parent3() {
      this.name = 'parent3'
      this.color = ['red', 'black']
    }

    function Child3() {
      Parent3.call(this)
      this.type = 'child3'
    }

    Child3.prototype  === new Parent3()
    var instance3 = new Child3()
    console.log(instance3)


    //组合继承的优化1   父类只执行了一次，但是Child4的构造函数也被修改了，被改成父类的constructor
    //怎么区分由子类实例化还是由父类实例化？？
    function Parent4() {
      this.name = 'parent5'
      this.color = ['red', 'black']
    }

    function Child4() {
      Parent4.call(this)
      this.type = 'child4'
    }

    Child4.prototype  = Parent4.prototype
    Child4.prototype.constructor = Child4
    var instance4 = new Child4()
    console.log(instance4)

    //组合继承的优化2
    function Parent5() {
      this.name = 'parent5'
      this.color = ['red', 'black']
    }

    function Child5() {
      Parent5.call(this)
      this.type = 'child5'
    }
    // var a = Object.create(Parent5.prototype) 
    Child5.prototype  === Object.create(Parent5.prototype)   //隔离开两个对象
    Child5.prototype.constructor = Child5
    var instance5 = new Child5()
    console.log(instance5)
  </script>
</body>
</html>